// language: metal2.1
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

typedef metal::float4 vec4f32_;
typedef metal::float3 vec3f32_;
struct VertexOutput {
    vec4f32_ position;
    vec3f32_ uv;
};
typedef metal::float4x4 mat4x4f32_;
struct Data {
    mat4x4f32_ proj_inv;
    mat4x4f32_ view;
};
typedef uint u32_;
typedef int i32_;
typedef float f32_;
typedef metal::float3x3 mat3x3f32_;
typedef constant Data& ptrData;
typedef constant mat4x4f32_& ptrmat4x4f32_;
typedef constant metal::float4& ptrf32_;

struct vs_mainInput {
};
struct vs_mainOutput {
    metal::float4 position [[position]];
    metal::float3 uv [[user(loc0), center_perspective]];
};
vertex vs_mainOutput vs_main(
  u32_ vertex_index [[vertex_id]]
, constant Data& r_data [[buffer(0)]]
) {
    i32_ tmp1_ = {};
    i32_ tmp2_ = {};
    tmp1_ = static_cast<int>(vertex_index) / 2;
    tmp2_ = static_cast<int>(vertex_index) & 1;
    i32_ _e9 = tmp1_;
    i32_ _e15 = tmp2_;
    vec4f32_ pos = metal::float4((static_cast<float>(_e9) * 4.0) - 1.0, (static_cast<float>(_e15) * 4.0) - 1.0, 0.0, 1.0);
    metal::float4 _e27 = r_data.view[0];
    metal::float4 _e32 = r_data.view[1];
    metal::float4 _e37 = r_data.view[2];
    metal::float3x3 inv_model_view = metal::transpose(metal::float3x3(_e27.xyz, _e32.xyz, _e37.xyz));
    mat4x4f32_ _e43 = r_data.proj_inv;
    metal::float4 unprojected = _e43 * pos;
    const auto _tmp = VertexOutput {pos, inv_model_view * unprojected.xyz};
    return vs_mainOutput { _tmp.position, _tmp.uv };
}


struct fs_mainInput {
    vec3f32_ uv [[user(loc0), center_perspective]];
};
struct fs_mainOutput {
    metal::float4 member_1 [[color(0)]];
};
fragment fs_mainOutput fs_main(
  fs_mainInput varyings_1 [[stage_in]]
, vec4f32_ position [[position]]
, metal::texturecube<float, metal::access::sample> r_texture [[texture(0)]]
) {
    constexpr metal::sampler r_sampler(
        metal::s_address::clamp_to_edge,
        metal::t_address::clamp_to_edge,
        metal::r_address::clamp_to_edge,
        metal::mag_filter::linear,
        metal::min_filter::linear,
        metal::coord::normalized
    );
    const VertexOutput in = { position, varyings_1.uv };
    metal::float4 _e4 = r_texture.sample(r_sampler, in.uv);
    return fs_mainOutput { _e4 };
}
